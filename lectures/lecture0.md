#Операционные системы.
Запускают программы, изолируют их друг от друга, чтобы крах одной не валил всё,
предоставляют унифицированный интерфейс для работы с железом (драйвера там всякие).

Тезис курса: **АБСТРАКЦИИ ПРОТЕКАЮТ**.
Хоть интерфейс может быть достаточно абстрактным, не зная, как он работает изнутри, используя
его по-разному, можно в разных случаях наткнуться на разные результаты, например, на сильное ухудшение производительности.
Хорошая [статья на эту тему](http://russian.joelonsoftware.com/Articles/LeakyAbstractions.html).

У ОС есть внешняя часть и есть *ядро*. Типичная работа программы: она что-то делает -> ей что-то понадобилось от ядра или оно её прервало ->
ядро что-то поделало -> программа выполняется дальше. 
Рассмотрим примерчик (псевдокод имеет много общего с питоном):

```python
def main():
    name = readln()
    string = "Hello, " + name + "!"
    writeln(string)
    exit(0) 
```

Здесь `readln`, `writeln` и `exit` - системные вызовы, которые работают в ядре. 
Давайте поймем, как ядро взаимодействует с программой. Перепишем наш код на несколько функций так, чтобы каждая из них
возвращала тройку `(что_сделать_ядру, с_какимим_аргументами, откуда_продолжать)`

```python
def main():
    return (Read, [], cont_main)
def cont_main(name): #здесь мы приняли то что вернул системный вызов
    string = "Hello, " + name + "!"
    return (Write, [string], cont_main2)
def cont_main2(wr_result): 
    return (Exit, [0], NONE)
``` 

Теперь ядро может интерпретировать эти тройки в цикле типа
```python
while (not processes.empty()):
    (p, pargs) = processes.pop()
    (syscall, args, cont) = p(pargs)
    switch(syscall):
        case Read:
            read_res = readln(args) #Ядро умеет обращаться с железом и читать из него
            processes.push(cont, read_res)
        case Write:
            ...
        # И так далее...
```

Следует заметить, что при такой реализации любой блокирующий вызов от программы будет останавливать ядро.
Чтобы этого не происходило, будем считать, что у нас есть некая *магия*, которая позволяет определить, 
можем ли мы сейчас выполнить конкретный процесс. Например, в `case N` будем класть процессы в массив `blocked`,
а после `switch`'a делать 
```python
for p in blocked:
    if (can_exec(p)):
        exec(p)
```

Далее код я приводить не буду, ибо работающая(если им верить) модель ядра на питоне есть 
на [странице курса](http://neerc.ifmo.ru/~os/static/model.py). 

##Иерарахия
Процессы организованы в дерево. У каждого процесса есть родитель. 
Порождаем процессы мы с помощью `fork` и `exec`.

`fork` дублирует процесс в текущем его состоянии и возвращает флажок, выполняется сейчас родитель или ребенок
(на самом деле 0 в ребёнка и `pid` в родителя, но об этом позже).

`exec` замещает полностью текущий контекст на выбранный (загруженный, например, из бинарника или откуда-то ещё).