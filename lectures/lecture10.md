# Линковка

Что есть библиотека? Набор кода, функции, которые импортируются в библиотеку и экспортируются из неё.

Рассмотрим программу как граф вызова функций. Есть начальная вершина (`_start`). Можно попилить граф на подграфы - это и будут
разные библиотеки. Компилятор производит код какой-то части, о которой он знает, а так же таблицу символов (для экспорта функций).
Вызовы внешних функций, о который он не знает, называется таблицей релокаций. На низком уровне табличка внешних функций
представляет собой список из пар `[(Offset, Relocation)]`, где `Relocation::==(Name, OffsetType)`. `OffsetType` - относительное смещение в файле или абсолютное.
`Offset` указывает на место вызова функции, которой пока что не существует.

## Статический линковщик

Все релокации имеют абсолютное адреса. Статический линковщик берет бинарники, объединяет секции кода и таблицы символов, и
забивает "дырки". После его работы таблица релокаций по-прежнему может быть не пустой. (мы можем долинковать потом)

Исполняемым файлом является тот бинарник, у которого пустая таблица релокаций(нет неизвестных ф-ий) и определён символ `_start`. Что с этим делать - понятно.

## Динамический линковщик

Дырки заполняются в рантайме. В бинарник мы добавляем `needed_libs` -
список библиотек, которые мы будем подключать, "обещание" того, чем мы будем закрывать дырки.
Проверяется, что таблица релокаций закрывается, но сама подстановка вызовов не происходит.

> **Проблема:** две проги юзают одну и ту же либу. Мы хотим загрузить её в память один раз и пошарить страницы памяти с ней, но в
виртуальной памяти процессов-пользователей либы она может попасть по разным адресам.

`GOT/PLT` - секции в бинарнике, заполняемые рантайм линковщиком.
Первое - отображение из имени в абсолютные адреса глобальных переменных, которые мы хотим получать из либы.
(Адрес куда загрузилась либа + смещение из таблицы символов либы).

`PLT` устроен почти так же, но хранит функции. Когда мы вызываем функцию динамической библиотеки,
просто делаем `jmp` на адрес оттуда.

Теперь каждая библиотека ссылается только на свой `GOT/PLT`, и её код можно шарить,
а эти таблицы заполнять для каждого процесса перед запуском.

Такое называется `PIC - position independet code`. Все обращения по адресам - относительные.

**(ТАМ ТАМ ТААААМ)** Не работает на `x86_32`, потому что там нет `mov` по относительному адресу - не можем пользоваться `GOT`.
(`mov rax, [GOT[n]]` - второй аргумент относителен.)

Придётся применять, как всегда, ~~грязные хаки и костыли~~ Enterprise решение.

`mov rax, [cur_adr+GOT]` - прибавили к текущему адресу относительный.
Как узнать текущий адрес?

```asm
main:
    call: foo ; вызвали функцию, но не сделали ret
foo:
    pop rax ; теперь на вершине стека адрес возврата foo - почти текущий
    mov rax, [rax + ? + GOT] ; ? - размер инструкции.
```

Чтобы не было проблем с branch prediction'ом (он ожидает, что из функции возвращаются), 
оформим это в отдельную функцию:

```asm
main:
    call bar
    mov rax, [rax + ? + GOT]
    ... ; что то дальше с выходом

bar:
    pop rax ; Положили со стека в rax
    push rax ; Вернули, чтобы сработал ret
    ret
```

`LD_PRELOAD` - можно установить этой переменной какое-то строковое значение,
 и либы из этой строчки будут использоваться с большим приоритетом в динамической линковке.
Например, `LD_PRELOAD=mymalloc.so emacs` запускает `emacs` со своим аллокатором памяти, который должен быть
определён в вашей `mymalloc.so`.

## Ленивая линковка

Если мы, например, программе передали не те аргументы,
то неразумно линковать её всю, ведь она завершится с ошибкой в самом начале.

Сделаем так, чтобы библиотеки линковались при первом вызове функции.
Добавим в `GOT` секцию `GOT.PLT`, теперь она будет содержать указатели на функции, а
`PLT` будет делать `jmp GOT.PLT.name`. Заодно, кстати, мы сделали секцию `PLT` констатной. (Это хорошо, так как `PLT` - выполняемый код, а `GOT` - просто секция данных).
После `jmp` поместим вызов линкера, а в `GOT.PLT` положим по умолчанию возврат в `PLT`.
Тогда при первом обращении к нему вызовется линкер и запишет туда адрес динамической функции.

> Так как линкер некому линковать, то в `GOT[0]` записывается его адрес, а в `GOT[1]` - его глобальные переменные.