# Терминалы и псевдотерминалы

Терминал - как файловый дескриптор, можно писать и читать.

**Canonical mode** - основной режим терминала. Нажимаете клавиши, символы отображаются и отправляются в read при нажатии `Enter`.

**Noncanonical mode** - всё остальное.

`termios` - структура для работы с терминалами.

```c
struct termios
{
    int c_iflags; //Input flags
    int c_oflags; //Output flags
    int c_cflags; //Control flags
    int c_lflags; //Local options
    int c_cc[];   //Control characters mapping
}
```

В `i,o` флагах можно задавать опции типа "поддержка больших букв, битность символов, ...". 
Сейчас мало что используется, большинство интересных флагов берутся из `lflags`.
Например, флаг `ECHO`. Если он выставлен, то символы, которые вы вводите, посылаются на вывод (т.е. видно, как вы их печатаете).
Это отключается, например, при вводе пароля.
`ECHOE` отвечает за обработку `backspace`. (В `cannonical mode` просто выкидывается символ из внутреннего буфера терминала, в `noncannonical` `backspace` обрабатывают сами программы).
`ECHO[K|NL]` - ещё что-то полезное для вывода... `ICANON` - переключение между режимами.
`ISIG` - надо ли посылать сигналы при всяких `Ctrl+C`

`break condition` - когда произошло отключение устройства (нашего терминала).
*Вспоминаем, что когда то терминалы были физическими устройствами.*
Флаги `IGNBRK` и `BRKINT` отвечают за поведение при этом. Вообще, есть `man termios`

## Системные вызовы для работы с терминалом

```c
tcgetattr(fd, termios*); //Читает настройки
tcsetattr(fd, options, termios*); //Устанавливает настройки

isatty(fd); //Проверяет, является ли fd дескриптором терминала

ioctl(...); //Вызов с кучей параметров, который отвечает за ВСЁ. tcget/set - обертки над ним.
```

Типичное использование - прочитали настройки, изменили в них флажок, записали.
Зачем `options`? Определяют, когда настройки вступят в силу. `TCSANOW` - сейчас; `TCSAFLUSH` - когда закончится текущая очередь на вывод;
`TCSADRAIN` -  как `FLUSH`, только ещё выбрасывает очередь на вход.

`c_cc[]` - массив, который хранит, какие клавиши являются управляющими (посылают сигналы и т.п.) и просто настройки, которые не выражаются флагами.
Там замэплены всякие `^C, ^D, ^S, ^Q`. Два интересных параметра: `VTIME` - максимальное время ожидания, `VMIN` - сколько минимум символов можно выводить.

* `TIME = 0, MIN = 0` - неблокирующий read
* `TIME = 0, MIN > 0` - блокирующий read
* `TIME > 0, MIN = 0` - read c таймаутом
* `TIME > 0, MIN > 0` - отсеивать "пачки" байт. Напр., ставим маленький таймаут и MIN=3. Обычная клавиша вернет байт по таймауту, "специальная" клавиша, которую мы ждем, вернет сразу 3.

Когда мы меняем размер окна, прилетает `SIGWINCH`.

## Как это устроено

Нижний уровень - `UART`. Серийный ввод-вывод.
Поверх него навешивается `line discipline` - штука с буферами и обработкой всяких `backspace`.
Уровнем выше `session management`, так же называется `tty driver` - обработка процессов и их групп, `job control` и прочее.

Так вот, `TTY` - это "legacy говно"©. Все нормальные ОС с окошечками теперь просто эмулируют эти TTY.
*The tty demystified* - статья на тему.

## Как работает ssh

Псевдотерминал - два устройства(fd), master и slave. Типа пайп. С `slave` концом можно делать всё то же самое, что с терминалами.
`master` контролирует его.

Удалённый доступ подключатеся к нужной машине, создаёт master-slave, и передаёт программе, с которой хочет работать (например `bash`) в качестве stdin/stdout slave терминал.
Если `bash` форкнется, создастся ещё один slave. Он спокойно может подключиться к тому же самому master'у.

Всё это делается системными вызовами `posix_openpt, grantpt, unlockpt, ptsname`.





