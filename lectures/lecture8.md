# Много файловых дескрипторов

> Проблема: у нас их дофига, и мы хотим работать одновременно со всеми.
(Например, мы сервер и к нам подключается куча клиентов). У каждого своя скорость доступа, и не хочется, чтобы
один подвисший `read` замедлял работу остальных.

Первое решение: неблокирующее чтение. Ставим на все дескрипторы флаг `O_NONBLOCK`,
бегаем по ним в цикле. Что не очень: активное ожидание (процессор крутится в цикле и жрёт энергию).

Второе: по процессу/треду на дескриптор. Ну понятно, что тут не так (создание тредов - дорого,
переключение - дорого, блокировки - дорого... ). Но если клиентов не очень много, то сойдёт.

Это были плохие решения. Теперь первое хорошее:
Дескрипторы - маленькие числа. Сделаем вызов `select(read_mask, write_mask)` - битовые маски интересующих нас fd.
Он заблокируется до того момента, пока один из дескрипторов в маске не станет доступен. Затем он выключит в масках те биты, которые по прежнему недоступны.
Небольшое улучшение - т.к. маски очень большие (~1024), передадим ещё `nmax` - максимальный используемый fd.
Но если, например, у нас используются два fd, но они с номерами `7` и `1000`, то нам всё равно нужно бегать по всей маске.

Следующее улучшение - вместо масок передавать просто список дескрипторов.
Получили `poll(n, pollfd* ev)`. `pollfd` - структура запроса. (Номер fd, что с ним делать - читать/писать/ещё, место под ответ).
Решили проблему разрозненных номеров fd, но не решили проблему, когда их много, но они малоактивны.

*Барабанная дробь...* `EPOLL`!!!
> В отличие от `select` и `poll`, которые есть в POSIX, `epoll` только в Linux.

Заметим, что в типичных юзкейсах список "слушаемых" дескрипторов и их флаги редко меняются.
`epoll` это использует. В ядре хранится список, аналогичный тому, что мы передали бы в `poll`.
Системными вызовами мы можем редактировать этот список. `epoll_wait` блокируется, пока что-то в списке не произойдёт.

Этот режим работы называется `Level-triggered` - нам говорят, когда можно что-то сделать.
Есть ещё `Edge-triggered` - нам говорят, когда произошло что-то новое.

# Сеть

`socket, bind, connect, listen, accept, recv, send` - вот это всё.

Сервер создает сокет `socket()`, затем вешает его на какой-то адрес и порт `bind()`,
потом ожидает подключения на него `listen()`, и когда там что-то появится, получает fd клиента `accept()`.
Клиент создает сокет `socket()` и подключается `connect()`.
> OSI - попытка сделать универсальную абстракцию под любой протокол. НЕ ВЫШЛО. Продолбали время, появился TCP/IP.

Уровни `OSI`:

1. Физический
2. Канальный
3. Сетевой
4. Транспортный
5. Сеансовый
6. Представления
7. Приложения

Что есть в `TCP/IP`:

* `IPv6, IPv4` - сетевые протоколы
* `TCP, UDP` - транспортные

Дальше рассказ про то, как пользоваться системными вызовами под заголовком.

```cpp
s = socket(domain, type, protocol);
//domain: Сетевой уровень, например IPv4 или Unix для unix-сокетов
//type: SOCK_STREAM, SOCK_DGRAM. Первый норм, второй ничего не гарантирует.
//protocol: IPPROTO_TCP, ... можно указать 0, тогда выберется автоматически. Напр., TCP для SOCK_STREAM
```

Что-то про DNS... Ну ведь все знают, что это такое, да?
Сервер, который переводит ваш человекочитаемый `vk.com` в IP-адрес.
`getaddrinfo(host, port, hints)`