# УГЛУБЛЕНИЯ и РАЗОБЛАЧЕНИЯ

## Системные вызовы

Как именно вызываются эти функции? Через прерывания.

Когда происходит прерывание, выполнение пользовательского кода приостанавливается,
и вызывается функция по адресу, который записан как обработчик этого прерывания.
Прерывания бывают разные, с разными обработчиками - таймер, `Double Fault` (если произошла ошибка при вызове прерывания), `Triple Fault` (да-да, если произошла ошибка в `Double Fault`.
Четвертого нет, ибо третий просто перезагружает машину), `General protection fault` - когда ошибка прав доступа, `Page fault` - ошибка страничной адресации, и ещё куча ошибок.
Нормальные тоже есть (типа пришли данные с сети/диска).

Прерывание на самом деле - просто число. Есть инстуркция ассемблера `int N`, которое вызывает прерывание N.
Номер прерывания системных вызовов - `0x80`. На самом деле, с каждым прерыванием ещё связан минимальный уровень привелегий,
которым нужно обладать, чтобы его вызывать - мы же не хотим, чтобы пользователь дергал прерывания фейлов или каких-то обновлений данных. (см. `runlevel` из курса ассемблера).

Чуть позже появились специальные команды в процессоре `sysenter/sysexit`.

Ещё есть очень интересный способ - повесить обработчик ошибки "несуществущая инструкция" туда же,
куда указывает обработчик системных вызовов, и вызывать... несуществующую инструкцию. Например, `ud2`. Её не существует.
*К счастью, системы, которые так устроены, не выжили, поэтому такой способ сейчас не работает.*

Аргументы системным вызовам обычно передаются через стек (в x64, на самом деле, какая-то часть идёт через регистры - вспоминаем calling conventions)
> Когда мы рассматривали модель ОС, мы говорили, что наш код прерывается в месте системных вызовов и возвращает место, откуда продолжать и код вызова.
На самом деле, ОС пофиг, когда прерывать наш код - она просто сохранит контекст и instruction/stack pointer.

## MMU

Тут про то, что страницы памяти в виртуальном адресном пространстве хранятся не в огромном линейном массиве, а в дереве -
на первом уровне 2^10 ячеек, каждая из которых указывает на массив размером 2^10, каждая ячейка
которого - страница (на x86) или указывает на ещё один массив, и ещё... (на х64, только там блоки не по 2^10, а по 2^9).
Короче, это всё было на ассемблере и плюсах. Флажки там доступа всякие, shared и пр.

### Как реализован swap

Пусть мы магическим образом поняли, что страница неиспользуется. Тогда запишем её на диск, а в памяти пометим как отсутствующую.
Когда пользователь обратится к странице, произойдёт ошибка адресации, вызовется обработчик `page fault`, посмотрит, что эта страница на самом деле есть, и загрузит её обратно.

Как определить, что страница не нужна? Периодически у неё сбрасывается `access` бит, и та, у которой он долго не выставлялся,
скорее всего не использутеся.

### Ленивый mmap - memory overcommit

*было на Сорокине, если что*

Когда процесс запрашивает память, даже если больше, чем у нас есть,
мы просто помечаем страницы как выделенные, но не ставим `present`. А уже при первом обращении подготовим страницу (найдем физическую и забьем нулями).
Поэтому делать больший `mmap/munmap` - дешево, а если обращаться к выделенной памяти - уже нет.

Так же, если у нас все процессы используют всю запрошенную память, а у нас столько нет, запускатся `OOM Killer`,
который использует кучу различных эвристик, чтобы понять, кого лучше убить.

## Сырые сокеты

`socket(AF_INET, SOCK_RAW, proto)`

На сырой сокет валятся ВСЕ данные выбранного протокола, причём с его заголовком (обычно нам доступно только содержимое пакета).
На этом основаны программы-снифферы типа Wireshark. Так как это небезопасно, создавать их может только root.
Если указать опцию `IP_HDRINC` получим заголовок не только протокольный (`TCP/UDP/etc`), но и транспортный (`IP`).
