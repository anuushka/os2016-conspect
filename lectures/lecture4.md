#Межпроцессное взаимодействие (сигналы)
Чтобы взаимодействовать пайпом, надо, чтобы оба процесса заранее знали об этом. Сигналы позволяют "неожиданно" обратиться к программе.
`man 7 signal`

Посылаются они системным вызовом `kill` (не перепутайте с одноименной утилитой).
"Давайте снова рисовать структурку" (`proc_info`). Теперь там есть маска `sigpending`. У каждого типа сигнала есть номер и соответствующее ему имя.
Напр., `SIGINT` это 2, `SIGKILL` - 9. Битовая маска показывает, какие сигналы пришли в процесс, но ещё не обработаны.
Из этого следует, что мы не запоминаем порядок и не можем одновременно "держать" два одинаковых сигнала.

Ещё в `proc_info` есть массив `sighandlers`, который содержит указатели на функции - обработчики соответствующих сигналов.
`sigblocked` - ещё одно поле в `proc_info`, которое позволяет игнорировать сигналы по той же маске.

    kernel() {
        ...
        p,args = pop_process()
        if (sigpending[1] && !sigblocked[1]) 
            sighandlers[1]()
        ...
    }
    
`man 2 signals` - deprecated. Перенаправляет на `man 2 sigaction`



**SIGKILL, SIGSTOP** - на самом деле не сигналы. Точнее, они, но они не доходят до процесса, а обрабатываются ядром. По `SIGKILL` мы просто выкидываем процесс из списка.
`SIGTERM` - аналог `SIGKILL`, только доходит до приложения, *намекая* ему, что время умирать.
`SIGSTOP` - означает приостановить процесс, он будет лежать в списке заблокированных, как будто совершен системный вызов. Пока не придет `SIGCONT`.
`SIGTSTP` - "мягкий" `SIGSTOP`. (Ctrl+Z)
`SIGINT` - (Ctrl+C)

Что происходит, когда во время выполнения обработки сигнала приходит другой?
Очень жаль. Функция-обработчик должна обладать `reentrancy` - не затрагивать внешние данные, поддерживать инварианты всегда внутри себя, а не только при входе и выходе из неё.
Короче говоря, обработчик сигнала может **ВНЕЗАПНО** вызваться во время своего же выполнения.

Если сигнал пришёл во время системного вызова, они могут прерваться. Например `read()` по сигналу возвращает -1 и выставляет код ошибки `EINTR`.
Сигналы приходят и для незаблокированных, и для заблокированных процессов. После обработки процесс "разблокируется". Исключением является `SIGSTOP` - после него прилетает только `SIGCONT`.

###Realtime сигналы
Приходят по порядку, могут таскать за собой данные (небольшие, размером с регистр). 
В `proc_info` появляется поле со списком (очередь) из таких сигналов. 
*Никому не нужны~~, как и ты~~*

##Ещё один способ IPC.
Для тех процессов, что состоят в отношении "родитель-ребенок".
Shared memory - когда виртуальные страницы памяти двух процессов указывают на один и тот же участок физической памяти.

Системный вызов `mmap` занимается маппингом виртуальной памяти куда-нибудь. В частности, им можно создать shared memory.


#Динамическая линковка
*понятия не имею, как это оказалось здесь*

Ну типа программа - граф вызовов функций, который мы попилили на куски. Задача динамической линковки - загружать одни и те же общие библиотеки, по разным адресам в памяти.
Т.е. чтобы вызвать функцию в ассемблере, нужно знать её адрес. Но два процесса могут положить библиотеку в своей памяти в разные участки. Нужно вычислить адреса всех её функций *динамически* и замапить их в одну и ту же общую память.